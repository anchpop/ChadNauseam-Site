import tez from "../../images/tezos/tez.svg";

<Layout
  subtitle="ꜩ Tezos Development Notes ꜩ"
  description="I just started working on Tezos, and I'm trying to write down everything I learn in case it's useful to anyone else."
>

Tezos is a cryptocurrency (units of the currency are called Tez). Tezos uses proof-of-stake for consensus and supports smart contracts.

# Tezos Concepts

## The Blockchain

Tezo's blockchain (like all blockchains I know of) represents a sequence of operations. Each operation represents a sequence of _external operations_ and is signed by the address of the account performing the operation (called the _source address_). There are three kinds of external operations:

1. **Transaction**.

   These represent transfers of tokens from one account to another. If the recipient account is a smart contract, the transaction can also have associated "parameters" to be interpreted by the smart contract, or the transaction can specify a specific smart contract "entrypoint".

1. **Contract creation**.

   This operation creates a smart contract. This requires the source code of the smart contract, some tokens (transferred from the source address), and an initial state for the contract.

   (Every contract has some storage that specifies its state. The contents of the storage evolve over time as the contract runs and help determine its behavior, so when creating a contract you have to specify the initial storage contents.)

1. **Delegations**.

   These assign the tokens of the source account to serve as the stake of another account. This does not transfer any tokens, and only works for "implicit accounts", not smart contracts.

### Types of accounts

Accounts in Tezos store tokens, and have a public and private key. Knowledge of the private key is sufficient to spend the tokens stored in the account.

There are two types of accounts in Tezos:

1. **Implicit accounts**.

   These are just wallets. Tokens stored in an implicit account can be spent by anyone with access to the private key. Its address is the hash of its public key, which will start with `tz1`, `tz2` or `tz3`.

1. **Programmable accounts**.

   The behavior of programmable accounts is specified by a _smart contract_ (defined as some Michelson code). Its address will start with `KT1`. A payment to this account will not necessarily succeed.

   Each smart contract has some amount of storage used to keep track of its state. The contents of the storage can be read and modified from the Michelson code.

## [Michelson](https://tezos.gitlab.io/alpha/michelson.html) - The Smart Contracts Language

Smart contracts are specified in a simple programming language called Michelson. The language is low-level, so usually you actually write the contracts in [Ligo](https://ligolang.org/), then compile to Michelson.

> A Michelson program is a series of instructions that are run in sequence: each instruction receives as input the stack resulting of the previous instruction, and rewrites it for the next one. The stack contains both immediate values and heap allocated structures. All values are immutable and garbage collected.

> The Michelson program receives as input a stack containing a single pair whose first element is an input value and second element the content of the storage space. It must return a stack containing a single pair whose first element is the list of internal operations that it wants to emit, and second element is the new contents of the storage space. Alternatively, a Michelson program can fail, explicitly using a specific opcode, or because something went wrong that could not be caught by the type system (e.g. gas exhaustion).

Here is an example of a simple Michelson program:

```
parameter unit;
storage unit;
code
  {
    CAR;

    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH nat 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH nat 2; ADD; PUSH nat 4; ASSERT_CMPEQ;

    # Offset a timestamp by 60 seconds
    PUSH int 60; PUSH timestamp "2019-09-09T12:08:37Z"; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH timestamp "2019-09-09T12:08:37Z"; PUSH int 60; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH mutez 1000; PUSH mutez 1000; ADD;
    PUSH mutez 2000; ASSERT_CMPEQ;

    NIL operation;
    PAIR;
  }

```

If you're familiar with stack-based languages, it should be pretty clear what's going on here. Let's look at just this one line:

```
PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
```

| Instruction     | Behavior                                                                                               | Current Stack State |
| --------------- | ------------------------------------------------------------------------------------------------------ | ------------------- |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2`                 |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2,2`               |
| `ADD;`          | Pops the top two values off the stack, adds them together, then pushes the result back onto the stack. | `4`                 |
| `PUSH int 4;`   | Pushes the int `4` onto the stack.                                                                     | `4,4`               |
| `ASSERT_CMPEQ;` | Pops the top two items off the stack and crashes the contract if they are not the same.                | ` `                 |

Michelson's semantics are specified [here](https://tezos.gitlab.io/alpha/michelson.html#language-semantics) ([opcode reference](https://tezos.gitlab.io/alpha/michelson.html#operations-on-integers-and-natural-numbers)). Strangely a definition for `ASSERT_CMPEQ` isn't present on that page.

## What is a Blockchain

A blockchain is a list of "blocks", which are just little pieces of data. A blockchain is called a "chain" because it's actually a special mathematical object. It's special because it has the property that there are only a couple operations that can be done on a chain. The only operations available are to create an empty chain, add a block to the end of an existing chain, or take a prefix of an existing chain.<Note>I mean, you can modify some data sitting on your computer however you want, but everyone would be able to tell by looking at it that you did one of those invalid things.</Note> There's no known way to "concatenate" two chains or modify just one block in the middle of a chain.

## Proof of work

You can store any information you want in a blockchain. For example, the Bitcoin and Tezos blockchains store a record of transactions. But on its own, a blockchain isn't useful as a currency, because you need a way to know which chain is _authoratative_. If Bob shows you a chain that says he has 2 bitcoins, and I show you a chain that says he only has 1 because he gave 1 to me, which one do you trust? What you need a way for everyone in the world to agree on a _particular_ blockchain. I can make my own blockchain and add some blocks, and someone else can make their own and add their own blocks, but how is a 3rd party supposed to know which chain is the "true" one?

One way of doing this, used by Bitcoin but not by Tezos, is called _Proof of Work_. Proof of work is incredibly simple so it pays to understand it before diving into Tezos.

In proof of work, we set up so generating a block takes a lot of computational work. The key is that everyone just agrees they'll use the longest chain available. Since making the chain logner takes work, the longest chain = the one with the most work behind it. If you had enough computing power, you could generate your own list of blocks completely independently from the current Bitcoin blockchain, and if it were long enough all Bitcoin nodes would immediately switch to using yours (although they would be pretty annoyed with you in real life). So even though this lets everyone agree on a particular blockchain, it doesn't give you confidence that the chain will never change. Bitcoin solves this ingeniously: they came up with a way to make people around the world try very hard to create the longest chain possible, so it will be very hard for you to make your own chain that beats them. Here's how they did that:

Every bitcoin block contains information besides some transactions - it also says who created it. Participants of the network agree that the creator of each block gets a little bit of free bitcoin (just created out of thin air). So if you want to make some money, you can set up your computer to try to find the longest existing chain, generate a block at the end of the chain, and write in the block that it was you who created it. As soon as you succeed, your chain will be the longest, meaning everyone will agree it's the definitive one. And since you wrote your wallet address in the block, everyone will agree that you get a little bit of free bitcoin that you can go spend. And nobody wants to waste time generating blocks for a shorter chain nobody uses, so other people who had the same idea as you will switch to trying to generate a block on _your_ chain. This basically means everyone is working together to make the longest chain possible.

Since everyone is trying to create the longest chain possible, it would be very difficult for you to make a new bitcoin blockchain from scratch. You would have to start out behind and have enough computing power to catch up to and exceed the length of the current chain. So this means there's one definitive chain everyone agrees on, and future chains that people agree on will always be extensions of the current one. (Put another way, they'll have the current chain as a prefix.) This prevents the blockchain from being retroactively changed, except to add new blocks.

But how do you spend a bitcoin? As we said before, transactions are stored in blocks. Each transaction has a fee, which goes to the person who creates the block your transaction is stored in. That means people who generate blocks want to put as many transactions in their blocks as possible, to collect the fee. If you want to know if a transaction from a wallet is valid,<Note>Each wallet has an associated private key, and knowledge of the key is required to "sign" the transaction. A transaction from a wallet must also be signed by the wallet's corresponding private key to be considered valid.</Note> what you do is assume the wallet balance started at 0 and look through every transaction in the longest blockchain you know of to compute their current balance. The transaction is valid if it's for an amount less than their current balance. Other miners will check your block for invalid transactions and reject it if they find any. Since this information is stored in the blockchain, and everyone always agrees on the current blockchain state, everyone always agrees on the current balance of everyone's wallets. And since future agreed-upon chains will always have the current chain as a prefix, everyone is confident that a transaction to them won't be erased from history.

[This 3blue1brown video](https://www.youtube.com/watch?v=bBC-nXj3Ng4&vl=en) explains more of the nitty-gritty of how all of this is accomplished cryptographically, so watch that to make sure you understand it.

## Exerpt from the Tezos whitepaper:

I'm posting this here because the formatting is broken on the [official site](https://wiki.tezosagora.org/whitepaper#mathematical):

> A blockchain protocol is fundamentally a monadic implementation of concurrent mutations of a global state. This is achieved by defining "blocks" as operators acting on this global state. The free monoid of blocks acting on the genesis state forms a tree structure. A global, canonical, state is defined as the minimal leaf for a specified ordering.
>
> This suggests the following abstract representation:
>
> Let <Im math="(\mathbf{S},\leq)"/> be a totally ordered, countable, set of possible states.
>
> Let <Im math="\oslash \notin \mathbf{S}"/> represent a special, invalid, state.
>
> Let <Im math="\mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \lbrace \oslash \rbrace}"/> be the set of blocks. The set of valid blocks is <Im math="\mathbf{B} \cap \mathbf{S}^{\mathbf{S}}"/>.
>
> The total order on <Im math="\mathbf{S}"/> is extended so that <Im math="\forall s \in \mathbf{S}, \oslash < s"/>. This order determines which leaf in the block tree is considered to be the canonical one. Blocks in <Im math="\mathbf{B}"/> are seen as operators acting on the state.
> All in all, any blockchain protocol (be it Bitcoin, Litecoin, Peercoin, Ethereum, Cryptonote, etc) can be fully determined by the tuple:
>
> <BlockMath math="(\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \{ \oslash \}} )" />
>
> The networking protocol is fundamentally identical for these blockchains. "Mining" algorithms are but an emergent property of the network, given the incentives for block creation.
>
> In Tezos, we make a blockchain protocol introspective by letting blocks act on the protocol itself. We can then express the set of protocols recursively as:
>
> <BlockMath math="\mathcal{P} = \lbrace (\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{(\mathbf{S} \times \mathcal{P}) \cup \{ \oslash \}} ) \rbrace" />

## Proof of Stake

Proof of Work is an example of a consensus algorithm. It allows everyone to come to consensus about the state of the blockchain, and have confidence that even though the chain is changing all the time, it will always have the current chain as a prefix (new blocks can be added but current ones will never change or be removed). But it does that by having a huge number of people doing the computationally hard problem of generating a block.

Proof of work works well enough for bitcoin, but it's fundamentally limited. Since Bitcoin was created, a better system has emerged, called _proof of stake_.

It's possible you noticed that in my description of proof of work, there was no penalty for creating bad blocks. Maybe you could try to submit a block with an invalid transaction - people would check it and throw it away, but nothing bad would happen to you. This is fine because checking that a transaction is valid is really easy - you just need to keep track of the balances of everyone's wallets and make sure you don't allow any transactions that would leave someone with a negative balance (well, you have to if you want people to accept your blocks).

# The Tezos dev environment

(Most tezos development is done in OCaml.)

Tezos is mostly developed on Debian, and if that works for you, you can use the [official docs](https://tezos.gitlab.io/introduction/howtoget.html#setting-up-the-development-environment-from-scratch) which should always be up-to-date.

I like Windows, so I followed [Daniel Hines](https://roamresearch.com/#/app/TezosDev/page/C2UthnLRL)'s guide to get an environment working using WSL. There's lots of good information in there.

## Directory Structure

At the time of this writing, the directory structure of the master branch looks something like this:

```
.
├── devtools
├── docs
├── scripts
├── src
│   ├── [...]
│   ├── proto_XXX_abcdefg
│   ├── proto_alpha
│   └── tooling
│       └── test
├── tests_python
├── tezt
└── vendors
```

I'm here to work on the protocol, so the most relevant folder under `src` is `proto_alpha`. The rest are just old versions of the protocol that you don't have to worry about.

</Layout>
