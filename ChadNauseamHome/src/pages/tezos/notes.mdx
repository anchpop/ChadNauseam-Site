import "../../components/css/tezos.css";
import blocktree from "../../images/tezos/basic_blocktree.jpg";

<Layout
  subtitle="ꜩ Tezos Development Notes ꜩ"
  description="I just started working on Tezos, and I'm trying to write down everything I learn in case it's useful to anyone else."
>

Tezos is a cryptocurrency (units of the currency are called Tez). Tezos uses proof-of-stake for consensus and supports smart contracts.

# Tezos Concepts

(Disclaimer: I'm still learning and I'm liable to use wrong terminology or give wrong explanations.)

## The Blocktree

### Numbers and Number Lines

You know numbers: `3`, `4`, `-1000`, `3.14`. What makes them numbers is that they can all be expressed as a point on the number line. Every number is what's called "a mathematical object", meaning just a well-defined thing we can do math on, but you can do math on other things. We could come up with a mathematical object that was defined as _two_ points on the number line. We could define rules, like saying two of these objects are equal if they represent the same two points on the number line. That would be a mathematical object called an unordered pair.

What I'm here to tell you is this: a blockchain is a mathematical object. Like how a number is defined as a point on the numberline, a blockchain is defined as a node on the blocktree. More on this soon!

### Conflict-Free Replicated Data Types

Let's imagine a numberline.<Note>(I'm going to use the connection between a number and a numberline to make an analogy to a blockchain and the blocktree.)</Note> A number line is easy to represent on a computer: there's only one possible number line so you don't actually have to store anything!

```
<------------------- - ------------------->
```

Now, say we randomly choose some points on the line.

```
<-------- -9 ------- 0 ---- 5 ------ 13 -->
```

We can represent this selection on a computer as a set of numbers, like `{-9, 0, 5, 13}`. Sets have an interesting property: they form a special type of value called a _Conflict-Free Replicated Data Type_ (CRDT)! This is a special data type that is basically trivial to replicate on a swarm of computers, without a centralized node to send or recieve updates.

Imagine computers connected in a peer-to-peer distributed network. Each computer in the network stores a set of numbers. Once in a while, one of the computers adds a number to their set, and wants to distribute the update to the rest of the computers, even ones they're not directly connected to. All it has to do is follow two simple rules:

1. When you add a number to your set, "gossip" your new set to every computer you're connected to

2. When a computer you're connected to sends you a set, combine it with your set, and if the combination is different from your old set, "gossip" the new set to every computer you're connected to.

This simple rule is "eventually consistent", meaning that if everyone stops updating their set, all the nodes will eventually come to a consensus on the current state of the set, as long as there's some path between any two nodes. It's kind of impressive that it does this without needing any centralized system to keep track of the current state!

### From the Number Line to the Block Tree

The number line is kind of like a set that contains every (real) number. The blocktree is a tree that contains every possible blockchain. (Each protocol, like Tezos, Bitcoin, Etherium, etc. has their own blocktree. Their current state is a specific node on that tree.)

You can actually store pretty much anything you want inside a blockchain. You just have to define it in a particular way: an initial state, and operations that act on that state. The blocktree is just the tree of every possible operation you could do on your initial state, then every operation you could do on _those_ states, etc. Like how a number line stretches infinitely far left and right, the blocktree stretches infinitely far downwards.

An example. A Bitcoin blockchain stores the contents of everyone's wallet. The initial state is everyone's wallet having 0 BTC in it. The operations are transactions which move BTC between wallets and mining events which creates BTC from nothing. The Bitcoin _blocktree_ is an infinitely-large tree of every possible sequence of those transactions and mining events.

Another example: Let's define our own blockchain system that stores something simpler. Instead of storing the contents of everyone's wallet, it just stores a positive integer<Note>This wouldn't be useful as a cryptocurrency (or anything else), but it could be fun.</Note>. The initial state is 1, and the operations are (just choosing randomly) to add 1 or multiply by 10.

The blocktree is an infinite tree of every possible sequence of "add 1" or "multiply by 10" that you can do to the initial state of 1. Unfortunately, I can't include an image of an infinitely large tree, but here's a sample:

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node"];
    2;
    10;
    11;
    1 -> 2[label="+1"];
    1 -> 10[label="×10"];
    2 -> 3[label="+1"];
    2 -> 20[label="×10"];
    10 -> 11[label="+1"];
    10 -> 100[label="×10"];
    3 -> 4[label="+1"];
    3 -> 30[label="×10"];
    11 -> 12[label="+1"];
    11 -> 110[label="×10"];
    20 -> 21[label="+1"];
    20 -> 200[label="×10"];
    100 -> 101[label="+1"];
    100 -> 1000[label="×10"];
}
`}
/>

So that's the _blocktree_ of our new positive-integer-storing-system. A _blockchain_ is just a particular path on the tree. Let's highlight the blockchain that leaves the state at `11`.

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node highlight"];
    2;
    10[class="highlight"];
    11[class="blast-highlight"];
    1 -> 2[label="+1"];
    1 -> 10[label="×10",class="highlight"];
    2 -> 3[label="+1"];
    2 -> 20[label="×10"];
    10 -> 11[label="+1",class="highlight"];
    10 -> 100[label="×10"];
    3 -> 4[label="+1"];
    3 -> 30[label="×10"];
    11 -> 12[label="+1"];
    11 -> 110[label="×10"];
    20 -> 21[label="+1"];
    20 -> 200[label="×10"];
    100 -> 101[label="+1"];
    100 -> 1000[label="×10"];
}
`}
/>

If we wanted to write this quickly, we'd write something like `[×10, +1]`, since it's assumed that anyone we're talking to knows that our initial state is always `1`.

You're within your rights to say some operations are invalid. Maybe you want to add a rule that says you can't apply `+1` to a number that's 1 below a power of 10. (That would make it so no two blockchains could describe the same number.) Blockchains that do an invalid operation just aren't in your blocktree, in the same way that the color red isn't on the number line.

Satoshi Nakamoto solved two problems that allowed him to invent Bitcoin:

1. Given a blocktree, how can we make everyone agree on a particular blockchain inside that blocktree?

   This allows everyone to agree how the balance of everyone's Bitcoin wallets. (Remember, the Bitcoin blocktree is a tree of transactions<Note numbered>Among other things.</Note> - your balance is just all the BTC you recieved minus all the BTC you sent.)

2. Once everyone agrees on a blockchain, how can we ensure that in the future they'll never change their mind and agree on a blockchain that isn't a descendent of the current one?

   This lets people be confident that their bitcoin balance will never go down unless they do a transaction. If the agreed-upon blockchain could change to a blockchain that isn't a descendent of the current one, Bitcoin would be next to useless as a currency. Someone could buy something from you and pay with a Bitcoin transaction, then the agreed-upon blockchain could change to one where that transaction didn't happen, which would leave you suckered (you would no longer have the item of sale and no one would agree that you had the BTC you were supposed to be paid for it).

Algorithms that do this are called _consensus algorithms_. Consensus algorithms that still work even if some people are malicious are called _byzantine consensus protocols_. Bitcoin uses a type of byzantine agreement protocol called _Proof of Work_ (POW). Tezos uses one called _Proof of Stake_ (POS). But they both have one thing in common: they operate on _cryptoeconomics_.

## Cryptoeconomics

POW and POS both accomplish byzantine consensus. But they can't work with a whole blocktree, any more than most algorithms can work with a whole number line. Given a _set of valid blockchains_, all a POW or a POS algorithm does<Note>POW and POS algorithms can also impose some restrictions on your blocktree, but they don't need to impose very many.</Note> is decide which blockchain your computer will feel is the "right" one.

That already makes problem #1 easier. Remember, it was "Given a blocktree, how can we make everyone agree on a particular blockchain inside that blocktree?". Now all we need to do is make sure everyone:

1. Agrees on a set of blockchains.

2. Agrees on the same blockchain from that set.

Using our toy example from earlier, a set of blockchains might look like `{[+1], [×10, +1, +1], [×10, ×10]}`. These would correspond to the states `{2, 12, 100}` Highlighting those blockchains on the blocktree we get:

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node highlight"];
    2[class="blast-highlight"];
    10[class="highlight"];
    11[class="highlight"];
    100[class="blast-highlight"];
    12[class="blast-highlight"];
    1 -> 2[label="+1",class="highlight"];
    1 -> 10[label="×10",class="highlight"];
    2 -> 3[label="+1"];
    2 -> 20[label="×10"];
    10 -> 11[label="+1",class="highlight"];
    10 -> 100[label="×10",class="highlight"];
    3 -> 4[label="+1"];
    3 -> 30[label="×10"];
    11 -> 12[label="+1",class="highlight"];
    11 -> 110[label="×10"];
    20 -> 21[label="+1"];
    20 -> 200[label="×10"];
    100 -> 101[label="+1"];
    100 -> 1000[label="×10"];
}
`}
/>

How do we agree on a set of blockchains? Simple. Anyone can add any blockchain they want to the set. As soon as they do, they send it to all the computers they're connected to. And if you recieve a set of blockchains from another computer with some new blockchains you didn't have in your own set, you combine it with your own set and share your new (expanded) set to all the computers _you're_ connected to. This is the same trick we used before to come to eventual consistency on a set of numbers! This is possible because sets of blockchains (like sets of numbers or sets of anything else) are CRDTs.

How do they agree on the same blockchain from that set? Well, that depends. For Proof of Work, you just use the biggest blockchain in your set. Now, I know what you're thinking. "But that doesn't solve Satoshi's second problem! Sure, everyone will agree on which is the longest blockchain in the set, but there's no guarantee that the longest blockchain in tomorrow's set will be a descendent of the longest blockchain in today's set!"

Well, that's where Satoshi's genius comes in. He realized that if you put certain constraints on the type of operations allowed in your blocktree, you can guarantee that will be the case using _cryptoeconomics_.

**(From now on, I'm going to refer to blockchain operations as _blocks_)**

## Proof of work

In Bitcoin's implementation of Proof of Work, we do a few things.

1. We make it so the blockchain state represents the current balance of everyone's wallets. Everyone's balance starts at zero, and blocks store "transactions" that move BTC from one wallet to another.

   Ah, but if everyone starts at zero, how does anyone get BTC in the first place?

1. We also write, in each blockchain operation, a little note saying who actually created that operation (it usually isn't the same person who did the transaction). We make agree that whoever's name is in that note gets a little bit of BTC as a reward. (It's just created out of thin air.)

   If people think BTC has any value, this makes it profitable to add new blocks, as long as you're adding them to the chain people in the future will agree is the longest. (You can add them to a shorter chain if you want, but there's no point because nobody cares about what's on any chain besides the longest one.)

1. We make it so it's very computationally expensive to compute a new valid operation to add to the blockchain set, but easy to check that an already-existing operation is valid.

   Trying to compute new blocks is called "mining". It's so difficult that only one valid operation is discovered every 10 minutes, despite millions of miners collectively using [15 Gigawatts](https://cbeci.org/)<Note numbered>At the time of this writing.</Note> of electrical power to discover valid blocks as fast as possible.

(All of this is done with some neat bits of cryptography. I can't do a better job at explaining it than [this 3blue1brown video](https://www.youtube.com/watch?v=bBC-nXj3Ng4&vl=en), so I recommend you just go watch that.)

Assuming it functions as described, just think about it. If people think BTC has any value, people will want to try to add blocks to whatever chain is going to be an ancestor of future longest-chains. What chain is going to be the ancestor of future longest-chains? Well, probably whichever chain is _currently_ the longest. And when they try to add blocks to it, they'll be making it even longer, inadvertently helping prove themselves right. If BTC has any value and miners are motivated by profit, future longest-chains _will_ be descendents of the current longest chain.

If over 50% of mining power is controlled by miners not motivated by profit, they could mess up that guarantee by not mining from the currently longest chain. But in doing so they would obliterate everyone's trust in Bitcoin, so they wouldn't be able to actually steal anything this way. Bitcoin's security is based on the assumption that nobody is going to spend millions of dollars on electricity and hardware for mining unless it's making them money. That's a cryptoeconomic guarantee rather than a cryptographic one, but it's good enough in practice.

## Exerpt from the Tezos whitepaper:

I'm posting this here because the formatting is broken on the [official site](https://wiki.tezosagora.org/whitepaper#mathematical):

> A blockchain protocol is fundamentally a monadic implementation of concurrent mutations of a global state. This is achieved by defining "blocks" as operators acting on this global state. The free monoid of blocks acting on the genesis state forms a tree structure. A global, canonical, state is defined as the minimal leaf for a specified ordering.
>
> This suggests the following abstract representation:
>
> Let <Im math="(\mathbf{S},\leq)"/> be a totally ordered, countable, set of possible states.
>
> Let <Im math="\oslash \notin \mathbf{S}"/> represent a special, invalid, state.
>
> Let <Im math="\mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \lbrace \oslash \rbrace}"/> be the set of blocks. The set of valid blocks is <Im math="\mathbf{B} \cap \mathbf{S}^{\mathbf{S}}"/>.
>
> The total order on <Im math="\mathbf{S}"/> is extended so that <Im math="\forall s \in \mathbf{S}, \oslash < s"/>. This order determines which leaf in the block tree is considered to be the canonical one. Blocks in <Im math="\mathbf{B}"/> are seen as operators acting on the state.
> All in all, any blockchain protocol (be it Bitcoin, Litecoin, Peercoin, Ethereum, Cryptonote, etc) can be fully determined by the tuple:
>
> <BlockMath math="(\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \{ \oslash \}} )" />
>
> The networking protocol is fundamentally identical for these blockchains. "Mining" algorithms are but an emergent property of the network, given the incentives for block creation.
>
> In Tezos, we make a blockchain protocol introspective by letting blocks act on the protocol itself. We can then express the set of protocols recursively as:
>
> <BlockMath math="\mathcal{P} = \lbrace (\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{(\mathbf{S} \times \mathcal{P}) \cup \{ \oslash \}} ) \rbrace" />

## Proof of Stake

Proof of Work is an example of a consensus algorithm. It allows everyone to come to consensus about the state of the blockchain, and have confidence that even though the chain is changing all the time, it will always have the current chain as a prefix (new blocks can be added but current ones will never change or be removed). But it does that by having a huge number of people doing the computationally hard problem of generating a block.

Proof of work works well enough for bitcoin, but it's fundamentally limited. Since Bitcoin was created, a better system has emerged, called _proof of stake_.

It's possible you noticed that in my description of proof of work, there was no penalty for creating bad blocks. Maybe you could try to submit a block with an invalid transaction - people would check it and throw it away, but nothing bad would happen to you. This is fine because checking that a transaction is valid is really easy - you just need to keep track of the balances of everyone's wallets and make sure you don't allow any transactions that would leave someone with a negative balance (well, you have to if you want people to accept your blocks).

## The Blockchain

Tezo's blockchain (like all blockchains I know of) represents a sequence of operations. Each operation represents a sequence of _external operations_ and is signed by the address of the account performing the operation (called the _source address_). There are three kinds of external operations:

1. **Transaction**.

   These represent transfers of tokens from one account to another. If the recipient account is a smart contract, the transaction can also have associated "parameters" to be interpreted by the smart contract, or the transaction can specify a specific smart contract "entrypoint".

1. **Contract creation**.

   This operation creates a smart contract. This requires the source code of the smart contract, some tokens (transferred from the source address), and an initial state for the contract.

   (Every contract has some storage that specifies its state. The contents of the storage evolve over time as the contract runs and help determine its behavior, so when creating a contract you have to specify the initial storage contents.)

1. **Delegations**.

   These assign the tokens of the source account to serve as the stake of another account. This does not transfer any tokens, and only works for "implicit accounts", not smart contracts.

### Types of accounts

Accounts in Tezos store tokens, and have a public and private key. Knowledge of the private key is sufficient to spend the tokens stored in the account.

There are two types of accounts in Tezos:

1. **Implicit accounts**.

   These are just wallets. Tokens stored in an implicit account can be spent by anyone with access to the private key. Its address is the hash of its public key, which will start with `tz1`, `tz2` or `tz3`.

1. **Programmable accounts**.

   The behavior of programmable accounts is specified by a _smart contract_ (defined as some Michelson code). Its address will start with `KT1`. A payment to this account will not necessarily succeed.

   Each smart contract has some amount of storage used to keep track of its state. The contents of the storage can be read and modified from the Michelson code.

## [Michelson](https://tezos.gitlab.io/alpha/michelson.html) - The Smart Contracts Language

Smart contracts are specified in a simple programming language called Michelson. The language is low-level, so usually you actually write the contracts in [Ligo](https://ligolang.org/), then compile to Michelson.

> A Michelson program is a series of instructions that are run in sequence: each instruction receives as input the stack resulting of the previous instruction, and rewrites it for the next one. The stack contains both immediate values and heap allocated structures. All values are immutable and garbage collected.

> The Michelson program receives as input a stack containing a single pair whose first element is an input value and second element the content of the storage space. It must return a stack containing a single pair whose first element is the list of internal operations that it wants to emit, and second element is the new contents of the storage space. Alternatively, a Michelson program can fail, explicitly using a specific opcode, or because something went wrong that could not be caught by the type system (e.g. gas exhaustion).

Here is an example of a simple Michelson program:

```
parameter unit;
storage unit;
code
  {
    CAR;

    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH nat 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH nat 2; ADD; PUSH nat 4; ASSERT_CMPEQ;

    # Offset a timestamp by 60 seconds
    PUSH int 60; PUSH timestamp "2019-09-09T12:08:37Z"; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH timestamp "2019-09-09T12:08:37Z"; PUSH int 60; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH mutez 1000; PUSH mutez 1000; ADD;
    PUSH mutez 2000; ASSERT_CMPEQ;

    NIL operation;
    PAIR;
  }

```

If you're familiar with stack-based languages, it should be pretty clear what's going on here. Let's look at just this one line:

```
PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
```

| Instruction     | Behavior                                                                                               | Current Stack State |
| --------------- | ------------------------------------------------------------------------------------------------------ | ------------------- |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2`                 |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2,2`               |
| `ADD;`          | Pops the top two values off the stack, adds them together, then pushes the result back onto the stack. | `4`                 |
| `PUSH int 4;`   | Pushes the int `4` onto the stack.                                                                     | `4,4`               |
| `ASSERT_CMPEQ;` | Pops the top two items off the stack and crashes the contract if they are not the same.                | ` `                 |

Michelson's semantics are specified [here](https://tezos.gitlab.io/alpha/michelson.html#language-semantics) ([opcode reference](https://tezos.gitlab.io/alpha/michelson.html#operations-on-integers-and-natural-numbers)). Strangely a definition for `ASSERT_CMPEQ` isn't present on that page.

# The Tezos dev environment

(Most tezos development is done in OCaml.)

Tezos is mostly developed on Debian, and if that works for you, you can use the [official docs](https://tezos.gitlab.io/introduction/howtoget.html#setting-up-the-development-environment-from-scratch) which should always be up-to-date.

I like Windows, so I followed [Daniel Hines](https://roamresearch.com/#/app/TezosDev/page/C2UthnLRL)'s guide to get an environment working using WSL. There's lots of good information in there.

## Directory Structure

At the time of this writing, the directory structure of the master branch looks something like this:

```
.
├── devtools
├── docs
├── scripts
├── src
│   ├── [...]
│   ├── proto_XXX_abcdefg
│   ├── proto_alpha
│   └── tooling
│       └── test
├── tests_python
├── tezt
└── vendors
```

I'm here to work on the protocol, so the most relevant folder under `src` is `proto_alpha`. The rest are just old versions of the protocol that you don't have to worry about.

</Layout>
