<Layout
  subtitle="Functional Programming Should Be More Complicated"
  description="My thoughts on the biggest pain points that I encounter when functional programming"
>

A selling point of functional programming is that it's supposed to be simpler. But is it really? Of all the mainstream functional programming languages, Haskell is the functionalest, and it ended up being (famously) difficult to learn.

It turns out that Haskell is both simpler than other languages _and_ harder to learn. The issue is that it's so simple that you have to build a whole tower of abstractions to get anything done. Monads are the classic example of this - there's no direct way to represent effectful code in Haskell because Haskell is lazy, but Monads allow you to _describe_ an effectful program. Then you give that description to the magic name `main` and the runtime executes it. It's a beautiful abstraction but it adds a layer of indirection and complexity when compared to an imperative program with the same behavior.

You can imagine a sliding scale between _core-language-simplicity_ and _practical-program-simplicity_. Functional languages prefer core-language-simplicity, while imperative languages prefer practical-program-simplicity. When an imperative programmer wants to do something (like iterate over elements in a collection) they usually have a specific language feature for that purpose (like loops). This complicates the core language, but then actual programs written in that language are simple. Functional languages, on the other hand, attempt to provide a simple base and build the same concepts in user space.

So where imperative languages have loops, functional languages have recursion, and expect you to use that to recreate loops yourself. (I'm being a little mean, for lists you can use `map` and `fold` which are always in the standard library, and you in Haksell can use `deriving` to automatically write equivalent functions for any custom type you make. The point is in a functional language the complexity is in userspace so you could have written them yourself, but in an imperative language you could never write `while` yourself.)

Having a simple core language might sound like something only ivory tower academics really care about. But it does come in handy! In Haskell for example, the _only_ thing a function can do is return a value computed from its inputs. Same inputs, same value, no side effects. <Note>Short of functions intended to aid debugging, there are no exceptions to this that a normal Haskell programmer will ever have to think about.</Note> And this simplicity allows you to write abstractions that would comparatively be a nightmare to write any other way. Undo/redo is the obvious example, because without mutation it's easy to keep a reference to an old version (and persistent data structures make that not as ineffecient as it sounds). Purity also enables [Software Transactional Memory](https://hackage.haskell.org/package/stm) and Tweag's amazing [Funflow library](https://github.com/tweag/funflow) (which actually uses Arrows, which are like Monads on steroids). With purity you can create expressive type systems which enable formal proofs about your code, like how Haskell and Rust code never encounters null reference exceptions (because `Maybe`/`Option` force you to prove you've checked and handled that case explicitly), or like how Haskell's [`Data.Justified`](https://hackage.haskell.org/package/justified-containers-0.3.0.0/docs/Data-Map-Justified.html) allows you to prove a key exists in a dictionary so accessing it is safe.

Despite that, I think functional languages have been stuck in an uncanny valley, where they've simplified their core language but not explored most of the power that simplification enables. And without that exploration, FP ends up being more limiting and less convenient than imperative programming. There are four under-resarched avenues I think are really promising.

## Debugging & Code editing

These are a bit simpler and more surface-level.

1. **Uniform Function Call Syntax** (UFCS). This adds an alternative syntax for invoking functions.

   Without UFCS: `foo(x, y z)` or `bar(x)`.

   With UFCS: `x.foo(y, z)` or `x.bar`.

   This enables _drastically_ better autocompletion in languages with good type systems. You just write `x.` and your IDE shows you every function whose first parameter could be `x`. <Note>That's much more useful than the other way around, where you type `foo` and then your IDE tells you every value could be the first parameter).</Note>

   It also makes manipulating values in a functional style much easier, because it removes the nesting that comes when using functions to iteratively tranform a piece of data. Compare `average(drop(sort(take(mylist, 10), 5)))` vs `mylist.take(10).sort.drop(5).average`.

   One disadvantage of this is that it makes namespacing trickier. If you have a function `serialization::to_json`, would you write `myvalue.serialization::to_json`? I think the solution here is simply to add syntax highlighting that makes `serialization::` dimmer than the surrounding code.

2. Don't rerun tests if the code doesn't change. [Unison](https://www.unisonweb.org/) does this right. If the code hasn't changed, and the test hasn't changed, don't rerun the test! This kind of analysis is much easier in a functional language, because the only things that can affect a function's execution are its code and its inputs.

3. Functional debugging.

   This is something that's always annoyed me - debugging in functional language is usually _so bad_, but in principle it could actually be much better than in any imperative language. Take this pseudocode:

   ```rust
   let handle_request = (request, path, old_state) => {
        let f = path.get_handler;
        let request = request.of_json;
        match request.f(old_state) {
          Ok((new_state, response)) =>
            (new_state, Response200(response.to_json.to_string)),
          Error(err) =>
            (old_state, Response500("Internal server error!"))
        }
      }
   ```

   What I want is to be able to write a test that calls this function. Then, if the test fails, I want to be able to click on it and enter a "debugging view". Say my test calls this function with `"{username: 'chad'}", "/api/getuser", 0`. I want to see:

   ```rust
   let handle_request = ("{username: 'chad'}", "/api/getuser", 0) => {
        getProductHandler = "/api/getuser".get_handler;
        { username: "chad" } = "{username: 'chad'}".of_json;
        match { username: "chad" }.getProductHandler(0) {
   //     Ok(new_state, response) =>
   //       (new_state, Response200(response.to_json.to_string)),
          Error(ProductNotFound("chad")) =>
            (0, Response500("Internal server error!"))
        }
      }  == (0, Response500("Internal server error!")),
   expected (1, Response200("{'firstname': 'Chad', lastname: 'Nauseam'}"))
   ```

   What I've done is replace every variable with its value. Because a functional language has no mutation, there's no need to have a step-by-step debugger, we can just view the whole execution at once. This lets us easily find the bug - `"/api/getuser".get_handler` is returning a function named `getProductHandler`, which is probably wrong.

   The trickiest part here is how to visualize `let f = path.get_handler;`. Lets say `path.get_handler` returns a lambda like `(json, state) => Ok((state+1, whatever))` - my suggestion is that we look through the context for a binding of that lambda to a name, and if we find one we just show the name. Otherwise we'd probably just have to keep viewing it as `f` and add something like this:

   ```rust
   let handle_request = ("{username: 'chad'}", "/api/getuser", 0) => {

         ╭──────────────────────────────────────────────────────── function
         │                                                         goes here
         f = "/api/getuser".get_handler;
         { username: "chad" } = "{username: 'chad'}".of_json;
         match { username: "chad" }.f(0) {
   //     Ok(new_state, response) =>
   //       (new_state, Response200(response.to_json.to_string)),
           Error(ProductNotFound("chad")) =>
             (0, Response500("Internal server error!"))
         }
       }  == (0, Response500("Internal server error!")),
    expected (1, Response200("{'firstname': 'Chad', lastname: 'Nauseam'}"))
   ```

   Then, if user wants to find the bug in `"/api/getuser".get_handler`, they can simply click it and see the same visualization shown here.

   I envision "custom function visualizations" for some built-in functions. For example `[1,2,3,4].map(myfunc)` could be visualized as

   ```
          [1, 2, 3,  4]
   myfunc  ↓  ↓  ↓   ↓
          [4, 8, 12, 16]
   ```

   And then the user can click one of those arrows to see the execution visualization for `myfunc(value)`.

   To handle `do` notation, I would give `>>=` the ability to output a value representing its "hidden state", and show that next to each line. That might be tricky for some lesser-used effects like the list monad, but I think it should get you 80% of the way there.

   Combine this with some clever semantic highlighting to highlight the each variable in a unique color, and use an analysis of the execution trace to comment out (or otherwise make grey) any code that doesn't effect the output of the function, and I think you would end up with a debugging experience more ergonomic than anything an imperative programmer could ever dream of.

## Effect systems (shout out to unison again)

## Recursion schemes (I want to attempt to explain them)

## Row polymorphism + Refinement types

</Layout>
```
