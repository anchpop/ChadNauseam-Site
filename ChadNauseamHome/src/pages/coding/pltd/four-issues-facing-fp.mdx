<Layout
  subtitle="Functional Programming Needs To Be More Complicated"
  description="My thoughts on the biggest pain points that I encounter when functional programming"
>

A selling point of functional programming is that it's supposed to be simpler. Is it really? Of all the mainstream functional programming languages, Haskell is the functionalest, and it ended up being (famously) difficult to learn.

It turns out that Haskell is both simpler than other languages _and_ harder to learn. The issue is that it's so simple that you have to build a whole tower of abstractions to get anything done. Monads are the classic example of this - there's no direct way to represent effectful code in Haskell because Haskell is lazy, but Monads allow you to _describe_ an effectful program. Then you set that description to Haskell's `main` function and the Haskell runtime executes it. It's a beautiful abstraction but it adds a layer of indirection and complexity when compared to an imperative program with the same behavior.

You can imagine a sliding scale between _core-language-simplicity_ and _practical-program-simplicity_. Functional langauges prefer core-langauge-simplicity, while imperative languages prefer practical-program-simplicity. When an imperative programmer wants to do something (like iterate over elements in a collection) they usually have a specific language feature for that purpose (like loops). This complicates the core language, but then actual programs written in that language are simple. Functional languages, on the other hand, attempt to provide a simple base and build the same concepts in user space.

So where imperative langauges have loops, functional langauges have recursion, and expect you to use that to recreate loops yourself. (I'm being a little mean, for lists you can use `map` and `fold` which are always in the standard library, and you in Haksell can use `deriving` to automatically write equivalent functions for any custom type you make. The point is in a functional langauge you could have written them yourself, but in an imperative language you could never write `while` yourself.)

Having a simple core language might sound like something only ivory tower academics really care about. But it does come in handy! In Haskell for example, the _only_ thing a function can do is return a value computed from its inputs. Same inputs, same value, no side effects. <Note>Short of functions intended to aid debugging, there are no exceptions to this that a normal Haskell programmer will ever have to think about.</Note> And this simplicity allows you to write abstractions that would comparatively be a nightmare to write any other way. Undo/redo is the obvious example, because without mutation it's easy to keep a reference to an old version (and persistent data structures make that not as ineffecient as it sounds). Other examples are [Software Transactional Memory](https://hackage.haskell.org/package/stm), Tweag's amazing [Funflow library](https://github.com/tweag/funflow) (which actually uses Arrows, which are like Monads on steroids), and writing formal proofs about your code. That last one sounds esoteric, but the Haskell (and Rust!) usage of `Maybe`/`Option` is actually a formal proof that you will never get a null reference exception, of the kind that's incredibly common in most imperative languages.

The issue is that this power takes you in a different direction than the direction imperative languages have taken. And I think to some extent, functional programming language designers are scared of doing that, because it would make their language less accessible to imperative programmers.

So right now, functional languages are stuck in kind of an uncanny valley, where they've simplified their core langauge but not explored most of the power that simplification would enable. And the lack of power is _really annoying_, because you often run into situations where you really want it and just don't have it.

1. Debugging (want to include diagrams here)

2. Recursion schemes (I want to attempt to explain them)

3. Row polymorphism + Refinement types (should this be split up?)

4. Effect systems (shout out to unison)

</Layout>
