import "../../../components/css/tezos.css";
import blocktree from "../../../images/tezos/basic_blocktree.jpg";

<Layout
  subtitle="ꜩ Tezos Development Notes ꜩ"
  description="I just started working on Tezos, and I'm trying to write down everything I learn in case it's useful to anyone else."
>

Tezos is a cryptocurrency (units of the currency are called Tez). Tezos uses proof-of-stake for consensus and supports smart contracts.

# Tezos Concepts

(Disclaimer: I'm still learning and I'm liable to use wrong terminology or give wrong explanations.)

## The Blocktree

### Numbers and Number Lines

You know numbers: `3`, `4`, `-1000`, `3.14519`. What makes them numbers is that they can all be expressed as a point on the number line. Every number is what's called "a mathematical object", meaning just a well-defined thing we can do math on, but you can do math on other things. We could come up with a mathematical object that was defined as _two_ points on the number line. We could define rules, like saying two of these objects are equal if they represent the same two points on the number line. That would be a mathematical object called an unordered pair.

What I'm here to tell you is this: a blockchain is a mathematical object. Like how a number is defined as a point on the number line, a blockchain is defined as a node on the blocktree. More on this soon!

### Conflict-Free Replicated Data Types

Let's imagine a number line.<Note>(I'm going to use the connection between a number and a number line to make an analogy to a blockchain and the blocktree.)</Note> A number line is easy to represent on a computer: there's only one possible number line so you don't actually have to store anything!

```
<------------------- - ------------------->
```

Now, say we randomly choose some points on the line.

```
<-------- -9 ------- 0 ---- 5 ------ 13 -->
```

We can represent this selection on a computer as a set of numbers, like `{-9, 0, 5, 13}`. Sets have an interesting property: they form a special type of value called a _Conflict-Free Replicated Data Type_ (CRDT)! This is a special data type that is basically trivial to replicate on a swarm of computers, without a centralized node to send or receive updates.

Imagine computers connected in a peer-to-peer distributed network. Each computer in the network stores a set of numbers. Once in a while, one of the computers adds a number to their set, and wants to distribute the update to the rest of the computers, even ones they're not directly connected to. All it has to do is follow two simple rules:

1. When you add a number to your set, "gossip" your new set to every computer you're connected to

2. When a computer you're connected to sends you a set, combine it with your set, and if the combination is different from your old set, "**gossip**" the new set to every computer you're connected to.

This simple rule is "eventually consistent", meaning that if everyone stops updating their set, all the nodes will eventually come to a consensus on the current state of the set, as long as there's some path between any two nodes. It's kind of impressive that it does this without needing any centralized system to keep track of the current state!

### From the Number Line to the Block Tree

The number line is kind of like a set that contains every (real) number. The blocktree is a tree that contains every possible blockchain. (Each protocol, like Tezos, Bitcoin, Ethereum, etc. has their own blocktree. Their current state is a specific node on that tree.)

You can actually store pretty much anything you want inside a blockchain. You just have to define it in a particular way: an initial state, and operations that act on that state. The blocktree is just the tree of every possible operation you could do on your initial state, then every operation you could do on _those_ states, etc. Like how a number line stretches infinitely far left and right, the blocktree stretches infinitely far downwards.

An example. A Bitcoin blockchain stores the contents of everyone's wallet. The initial state is everyone's wallet having 0 BTC in it. The operations are transactions which move BTC between wallets and mining events which creates BTC from nothing. The Bitcoin _blocktree_ is an infinitely-large tree of every possible sequence of those transactions and mining events.

Another example: Let's define our own blockchain system that stores something simpler. Instead of storing the contents of everyone's wallet, it just stores a positive integer<Note>This wouldn't be useful as a cryptocurrency (or anything else), but it could be fun.</Note>. The initial state is 1, and the operations are (just choosing randomly) to add 1 or multiply by 10.

The blocktree is an infinite tree of every possible sequence of "add 1" or "multiply by 10" that you can do to the initial state of 1. Unfortunately, I can't include an image of an infinitely large tree, but here's a sample:

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node"];
    2;
    10;
    11;
    1 -> 2[label="+1"];
    1 -> 10[label="×10"];
    2 -> 3[label="+1"];
    2 -> 20[label="×10"];
    10 -> 11[label="+1"];
    10 -> 100[label="×10"];
    3 -> 4[label="+1"];
    3 -> 30[label="×10"];
    11 -> 12[label="+1"];
    11 -> 110[label="×10"];
    20 -> 21[label="+1"];
    20 -> 200[label="×10"];
    100 -> 101[label="+1"];
    100 -> 1000[label="×10"];
}
`}
/>

So that's the _blocktree_ of our new positive-integer-storing-system. A _blockchain_ is just a particular path on the tree. Let's highlight the blockchain that leaves the state at `11`.

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node highlight"];
    2[class="blur"];
    3[class="blur"];
    20[class="blur"];
    11[class="blur"];
    100[class="blur"];
    4[class="blur"];
    30[class="blur"];
    21[class="blur"];
    200[class="blur"];
    12[class="blur"];
    110[class="blur"];
    101[class="blur"];
    1000[class="blur"];
    10[class="highlight"];
    11[class="blast-highlight"];
    1 -> 2[label="+1",class="blur"];
    1 -> 10[label="×10",class="highlight"];
    2 -> 3[label="+1",class="blur"];
    2 -> 20[label="×10",class="blur"];
    10 -> 11[label="+1",class="highlight"];
    10 -> 100[label="×10",class="blur"];
    3 -> 4[label="+1",class="blur"];
    3 -> 30[label="×10",class="blur"];
    11 -> 12[label="+1",class="blur"];
    11 -> 110[label="×10",class="blur"];
    20 -> 21[label="+1",class="blur"];
    20 -> 200[label="×10",class="blur"];
    100 -> 101[label="+1",class="blur"];
    100 -> 1000[label="×10",class="blur"];
}
`}
/>

If we wanted to write this quickly, we'd write something like `[×10, +1]`, since it's assumed that anyone we're talking to knows that our initial state is always `1`.

You're within your rights to say some operations are invalid. Maybe you want to add a rule that says you can't apply `+1` to a number that's 1 below a power of 10. (That would make it so no two blockchains could describe the same number.) Blockchains that do an invalid operation just aren't in your blocktree, in the same way that the color red isn't on the number line.

Satoshi Nakamoto solved two problems that allowed him to invent Bitcoin:

1. **Consensus**: Given a blocktree, how can we make everyone agree on a particular blockchain inside that blocktree?

   This allows everyone to agree how the balance of everyone's Bitcoin wallets. (Remember, the Bitcoin blocktree is a tree of transactions<Note numbered>Among other things.</Note> - your balance is just all the BTC you received minus all the BTC you sent.)

2. **Common Prefix**: Once everyone agrees on a blockchain, how can we ensure that in the future they'll never change their mind and agree on a blockchain that isn't a descendent of the current one?

   This lets people be confident that their bitcoin balance will never go down unless they do a transaction. If the agreed-upon blockchain could change to a blockchain that isn't a descendent of the current one, Bitcoin would be next to useless as a currency. Someone could buy something from you and pay with a Bitcoin transaction, then the agreed-upon blockchain could change to one where that transaction didn't happen, which would leave you suckered (you would no longer have the item of sale and no one would agree that you had the BTC you were supposed to be paid for it).

Algorithms that do this are called _consensus algorithms_. Consensus algorithms that still work even if some people are malicious are called _byzantine consensus protocols_. Bitcoin uses a type of byzantine agreement protocol called _Proof of Work_ (PoW). Tezos uses one called _Proof of Stake_ (PoS). But they both have one thing in common: they operate on _cryptoeconomics_.

## Cryptoeconomics

PoW and PoS both accomplish byzantine consensus. But they can't work with a whole blocktree, any more than most algorithms can work with a whole number line. Given a _set of valid blockchains_, all a POW or a PoS algorithm does<Note>POW and PoS algorithms can also impose some restrictions on your blocktree, but they don't need to impose very many.</Note> is decide which blockchain your computer will feel is the "right" one.

That already makes problem #1 easier. Remember, it was "Given a blocktree, how can we make everyone agree on a particular blockchain inside that blocktree?". Now all we need to do is make sure everyone:

1. Agrees on the set of blockchains.

2. Agrees on the same blockchain from that set.

Using our toy example from earlier, a set of blockchains might look like `{[+1], [×10, +1, +1], [×10, ×10]}`. These would correspond to the states `{2, 12, 100}` Highlighting those blockchains on the blocktree we get:

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node highlight"];
    2[class="blast-highlight"];
    10[class="highlight"];
    3[class="blur"];
    20[class="blur"];
    11[class="highlight"];
    100[class="blast-highlight"];
    4[class="blur"];
    30[class="blur"];
    21[class="blur"];
    200[class="blur"];
    12[class="blast-highlight"];
    110[class="blur"];
    101[class="blur"];
    1000[class="blur"];
    1 -> 2[label="+1",class="highlight"];
    1 -> 10[label="×10",class="highlight"];
    2 -> 3[label="+1",class="blur"];
    2 -> 20[label="×10",class="blur"];
    10 -> 11[label="+1",class="highlight"];
    10 -> 100[label="×10",class="highlight"];
    3 -> 4[label="+1",class="blur"];
    3 -> 30[label="×10",class="blur"];
    11 -> 12[label="+1",class="highlight"];
    11 -> 110[label="×10",class="blur"];
    20 -> 21[label="+1",class="blur"];
    20 -> 200[label="×10",class="blur"];
    100 -> 101[label="+1",class="blur"];
    100 -> 1000[label="×10",class="blur"];
}
`}
/>

How do we agree on the set of blockchains? Simple. Anyone can add any blockchain they want to their set. As soon as they do, they send their new set to all the computers they're connected to. When you receive a set from another computer, you combine it with your own set and share your new (expanded) set to all the computers _you're_ connected to. This is the same trick we used before to come to eventual consistency on a set of numbers! This is possible because sets of blockchains (like sets of numbers or sets of anything else) are CRDTs. **In general, this is called a gossip protocol**.

How do they agree on the same blockchain from that set? Well, that depends. For Proof of Work, you just use the biggest blockchain in your set. Now, I know what you're thinking. "But that doesn't solve Satoshi's second problem, the **common prefix**! Sure, everyone will agree on which is the longest blockchain in the set, but there's no guarantee that the longest blockchain in tomorrow's set will be a descendent of the longest blockchain in today's set!"

Well, that's where Satoshi's genius comes in. He realized that if you put certain constraints on the type of operations allowed in your blocktree, you can guarantee that will be the case using _cryptoeconomics_.

**(From now on, I'm going to refer to blockchain operations as _blocks_)**

## Proof of work

In Bitcoin's implementation of Proof of Work, we do a few things.

1. We make it so the blockchain state represents the current balance of everyone's wallets. Everyone's balance starts at zero, and blocks store "transactions" that move BTC from one wallet to another.

   "Ah, but if everyone starts at zero, how does anyone get BTC in the first place?"

1. We also write, in each blockchain operation, a little note saying who actually created that operation (it usually isn't the same person who did the transaction). We agree that whoever's name is in that note gets a little bit of BTC as a reward. (It's just created out of thin air.)

   If people think BTC has any value, this makes it profitable to add new blocks, as long as you're adding them to the chain people in the future will agree is the longest. (You can add them to a shorter chain if you want, but there's no point because nobody cares about what's on any chain besides the longest one.)

1. We make it so it's very computationally expensive to compute a new valid operation to add to the blockchain set, but easy to check that an already-existing operation is valid.

   Trying to compute new blocks is called "mining". It's so difficult that only one valid operation is discovered every 10 minutes, despite millions of miners collectively using [15 Gigawatts](https://cbeci.org/)<Note numbered>At the time of this writing.</Note> of electrical power to discover valid blocks as fast as possible.

(All of this is done with some neat bits of cryptography. I can't do a better job at explaining it than [this 3blue1brown video](https://www.youtube.com/watch?v=bBC-nXj3Ng4&vl=en), so I recommend you just go watch that.)

Assuming it functions as described, just think about it. If people think BTC has any value, people will want to try to add blocks to whatever chain is going to be an ancestor of future longest-chains. What chain is going to be the ancestor of future longest-chains? Well, probably whichever chain is _currently_ the longest. And when they try to add blocks to it, they'll be making it even longer, inadvertently helping prove themselves right. If BTC has any value and miners are motivated by profit, future longest-chains _will_ be descendants of the current longest chain.

If over 50% of mining power is controlled by miners not motivated by profit, they could mess up that guarantee by not mining from the currently longest chain. But in doing so they would obliterate everyone's trust in Bitcoin, so they wouldn't be able to actually steal anything this way. Bitcoin's security is based on the assumption that nobody is going to spend millions of dollars on electricity and hardware for mining unless it's making them money. That's a cryptoeconomic guarantee rather than a cryptographic one, but it's good enough in practice.

This is a generic system that can support a blockchain with any set of operations, as long as the operations can be quickly checked for their validity. You can (and should) allow transactions as valid operations - people who make transactions don't need to do anything but connect to the gossip network and say "hey, I'd like to make a transaction to this address, and I'm willing to pay this fee". If you set it up so miners who include the transaction in their block get the transaction fee added to their account, miners will be incentivized to listen for transactions and add them to any blocks they manage to create. There's a catch though: all the network participants have to verify that the transactions (and anything else you want to put in the blockchain) are valid and discard the chain otherwise. This fundamentally limits what you can do with PoW.

## Nakamoto-Style Proof of Stake

Proof of work works okay for Bitcoin's purposes, but it's fundamentally limited. It also necessitates a large number of participants trying to solve hash puzzles as fast as possible, a fundamentally useless waste of resources. A more flexible system has emerged, called _Proof of Stake_.

Proof of work requires that it's much easier to block is valid than to generate a valid block from scratch.<Note>The Bitcoin network dynamically adjusts the difficulty of creating new blocks to keep the rate of new block creation to around once every 10 minutes. (The increased difficulty only makes it harder to generate valid blocks, not check blocks for their validity.) Thanks to this, the network can support an unlimited number of miners.</Note> That's because, for its security, every computer in the network has to check that new blocks are valid, but they can all independently be working on generating new blocks. If there's 100,000 participants on the network, all 100,000 of those participants will work together to generate each next block, which will then be need to be independently checked for validity by all 100,000 participants. So you're limited to making the computers do the kind of work where it's at least 100,000x faster to check that an answer is right than it is to compute what the right answer is in the first place.

Proof of Work guarantees a property called _chain quality_, which is basically just that the consensus chain (agreed upon by honest participants) will always be valid. It's easy to guarantee this because if you're an honest participant you can just check that each chain is valid before coming to consensus on it. You can check it because checking the validity is fast, so it doesn't matter if it happens 100,000 per block. Proof of Work guarantees chain quality cryptographically, so you can be confident it's always true. Proof of Stake only guarantees chain quality cryptoeconomically, which isn't quite as good, but it's worth it because it allows you to guarantee the quality of _any_ chain where the validity of an operation can be computed at all (even if it's very slow).

Proof of Work requires that more than 50% of computing power behaves honestly (if BTC has any value, behaving honestly is profitable, so it's a cryptoeconomic assumption). Proof of stake works as long as 50% of _stake_ behaves honestly (where stake can be many things but usually is something like "people who hold some of the cryptocurrency and decide to be stakers"). Here's how it works:

First, the old:

1. All the participants in the network have a unique identifier, like a wallet address.

1. PoS algorithms select a blockchain out of a set of blockchains.

   1. Just like PoW, it does that by picking the longest chain in the set. Computers come to consensus on this set via a **gossip protocol**.

   1. We need some particular restrictions on valid operations on the blocktree if we want to make our system satisfy the **common prefix** constraint.

1. Blocks contain the hash of their predecessor.<Note numbered>Go back and watch the 3b1b video if you don't know what this means.</Note>

1. Like PoW, not everyone who uses the cryptocurrency or whatever has to be involved in the process that secures the network. In PoW, people involved in the network-securing process are called _miners_, in PoS they're called _bakers_.

1. Blocks contain and identifier of the baker, and are signed by that baker. You can't make a block that looks like it came from another baker, because the signature you signed it with wouldn't match the identifier in the block.

Ok, now for the new:

1. We discretize time into _slots_. This is like how I can take a number that represents the current time (like the number of milliseconds since 1970) and tell you what day it is. There might be one slot every 10 minutes or every 30 seconds. It's important that honest participants roughly agree on the current slot. We'll assume slots are 10 minutes long, just for consistency with Bitcoin, even though Tezos's slots are shorter than that.

   Blocks also contain the slot number of the slot they were created in.

1. We need a lottery function that bakers can use to check if you're the _winner_ for a particular slot. It's important that everyone agrees on whether or not someone is the winner, and that there's only one.

Ok, here's the process for how to be a proper baker:

1. You're always listening to the gossip network to get an up-to-date set of blockchains to choose from.

1. Every slot, check the lottery function to see if you're the winner. If so, good news: you get to make a block (and make some money)! Here's how to create a block:

   1. Calculate the current longest chain, discarding blocks with a slot number above the current slot.

   1. Add a new block at the end of that chain. It just needs to contain a hash of the last block of that chain, the current slot, your identity, and your signature.

   1. Gossip the new blockchain you just created. Other participants will check the slot number and identifier to make sure it was created by the rightful winner of that slot. (So don't bother if you weren't a winner.)

1. If you receive a blockchain from someone, make sure the blocks have the right hashes and were created by the slot lottery winner and whatnot, but don't bother checking the actual operation inside.

So, how is this secure at all? Well, its security is cryptoeconomic, and depends on how you distribute the _stake_. Becoming a baker needs to require a _security deposit_, and you don't get it back until you announce you're going to stop baking. The easiest way is to just require a deposit of the cryptocurrency. (So, you add a special block operation that says "I would like to become a baker" that subtracts the security deposit from your account, and one that says "I'm done being a baker" that gives it back.) People actually have to want to become stakers, so just like how block creators in PoW get a reward for creating one, stakers should get a reward when they win the lottery and get to create a block. If the reward is big enough, people who value your cryptocurrency will want to become stakers to get the reward.

Currently, this algorithm does _not_ do a good job of guaranteeing chain quality. Actually, all it guarantees is that the ratio of good operations to bad operations will be at least the ratio of honest bakers to dishonest bakers. And worse, bakers have no incentive to be honest! What I've just described is called (for some reason) Nakamoto-Style Proof of Stake.

## Tezos-Style Proof of Stake 😎

### The cryptographic side

Tezos's Proof of Stake algorithm is a bit more sophisticated. It guarantees complete chain quality as long as over 50% of the stake is honest. We'll explain that first, then explain how Tezos cryptoeconomically ensures over that over 50% of the stake has a powerful incentive to act honestly. (But for now, just assume over 50% are honest.)

First, we should abstract a few things. Here's an OCaml definition for what a Tezos block looks like:

```ocaml
type block = {
  pred: Block_hash.t;
  header: ???;
  operations: ??? list;
  timestamp: float;
}
```

This is actually simplifying a bit. First, I've taken some irrelevant bits (like the specific operations and header) and replaced them with `???` so you know you don't need to worry about their exact types. Second, you actually only store the hashes of the operations in the block header, not the operations themselves, but we can ignore that for now. Basically, the only info the system _needs_ is the hash of the predecessor block and the timestamp. Moving on!

Like in Nakamoto-Style, we divide time into slots and say we're going to make one block per slot. We also group the blocks into cycles, each a few thousand blocks long.<Note numbered>4096 blocks, to be exact.</Note> Like in Nakamoto-Style, each block is mined by a randomly-selected lottery winner (chosen randomly from all the bakers). The random number generator is seeded with a value determined in the previous two cycles. <Note>The random number generator is seeded with [this algorithm using the participants of the last cycle](https://keybase.io/blog/cryptographic-coin-flipping), and it's secure as long at least one of the participants is honest.</Note> The random number is used to select several participants from the pool of bakers: some are selected to be _miners_, and some are selected to be _bakers_. We actually select multiple miners, and we also select several participants to be _signers_. (Spoilers for the cryptoeconomic section: mining and signing both offer a reward and require a "security deposit".)

The reason we select multiple miners is because we still want to be able to get something done if one miner's computer is offline. The miners are put in a random order, called the _priority_. The highest-priority miner has 1 minute to generate a block. If 1 minute is up and they still haven't created a block, the next-highest priority miner gets a 1-minute chance, etc.

Of course, this introduces an issue. If there are multiple miners, and both generate a block, now you have two separate blockchains and must choose one of them to agree upon. (Since the blocks are all the same except for the last block, it looks like a fork in the chain when you show it on the blocktree, so this is called a fork.)

<Graphviz
  dot={`digraph {
    bgcolor="transparent";
    edge [style="none"];
    node [style="none"];
    1[class="blocktree-root-node highlight"];
    2[class="blur"];
    10[class="highlight"];
    3[class="blur"];
    20[class="blur"];
    11[class="highlight"];
    100[class="blur"];
    4[class="blur"];
    30[class="blur"];
    21[class="blur"];
    200[class="blur"];
    12[class="blast-highlight"];
    110[class="blast-highlight"];
    101[class="blur"];
    1000[class="blur"];
    1 -> 2[label="+1",class="blur"];
    1 -> 10[label="×10",class="highlight"];
    2 -> 3[label="+1",class="blur"];
    2 -> 20[label="×10",class="blur"];
    10 -> 11[label="+1",class="highlight"];
    10 -> 100[label="×10",class="blur"];
    3 -> 4[label="+1",class="blur"];
    3 -> 30[label="×10",class="blur"];
    11 -> 12[label="+1",class="highlight"];
    11 -> 110[label="×10",class="highlight"];
    20 -> 21[label="+1",class="blur"];
    20 -> 200[label="×10",class="blur"];
    100 -> 101[label="+1",class="blur"];
    100 -> 1000[label="×10",class="blur"];
}
`}
/>

Actually, this can happen in Bitcoin too, when two people solve a hash puzzle at nearly the same time. It's called a soft fork and in Bitcoin, miners just select one of the chains based on a rule of their choosing and keep mining. Around half will be mining on one fork, and the other half will be mining on the other fork, but the one with more mining power on it will eventually outpace the other and (since it's longer) start to be considered the consensus fork, and miners (who have no interest in mining on a shorter, non-consensus chain that no one cares about) will switch over to the longer fork and the issue will resolve itself. For this reason, when doing a Bitcoin transaction you often have to wait for several blocks to be mined (say, between 3 and 10) before you can have confidence that your transaction will be part of the blockchain. Since Bitcoin blocks are mined every 10 minutes, this means waiting 30 minutes to an hour before you can have confidence in your transaction. Could be better!

Picking the longest chain wouldn't work for Tezos-Style Proof of Stake, however. It works in Proof of Work because computing power is limited by the real world, and so needs to be divided between the forks. But blocks are easy to make in Tezos, you can easily make one per slot, so if there's a fork for whatever reason miners will just start mining on both forks and they'll stay equally long. In Tezos-Style Proof of Stake, all of the signers can sign each block, then we pick the chain with the most total _signatures_. This works because we're assuming that 50% of the stake is honest and will only sign one of the available blocks, and will sign the highest-priority block they know about.<Note numbered>Each block contains the information necessary to determine the priority of the miner who created it with cryptographic certainty.</Note>

Unfortunately, everyone still needs to check that the actual operations on the chain are valid. It's very difficult to motivate miners to only create valid blocks without everyone checking the blocks they create for validity. Bitcoin miners not doing this caused them to [accidentally create a long-lived fork](https://bitcoin.stackexchange.com/questions/38437/what-is-spv-mining-and-how-did-it-inadvertently-cause-the-fork-after-bip66-wa) a few years back.

### The cryptoeconomic side

## Excerpt from the Tezos whitepaper:

I'm posting this here because the formatting is broken on the [the Agora](https://wiki.tezosagora.org/whitepaper#mathematical):

> A blockchain protocol is fundamentally a monadic implementation of concurrent mutations of a global state. This is achieved by defining "blocks" as operators acting on this global state. The free monoid of blocks acting on the genesis state forms a tree structure. A global, canonical, state is defined as the minimal leaf for a specified ordering.
>
> This suggests the following abstract representation:
>
> Let <Im math="(\mathbf{S},\leq)"/> be a totally ordered, countable, set of possible states.
>
> Let <Im math="\oslash \notin \mathbf{S}"/> represent a special, invalid, state.
>
> Let <Im math="\mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \lbrace \oslash \rbrace}"/> be the set of blocks. The set of valid blocks is <Im math="\mathbf{B} \cap \mathbf{S}^{\mathbf{S}}"/>.
>
> The total order on <Im math="\mathbf{S}"/> is extended so that <Im math="\forall s \in \mathbf{S}, \oslash < s"/>. This order determines which leaf in the block tree is considered to be the canonical one. Blocks in <Im math="\mathbf{B}"/> are seen as operators acting on the state.
> All in all, any blockchain protocol (be it Bitcoin, Litecoin, Peercoin, Ethereum, Cryptonote, etc) can be fully determined by the tuple:
>
> <BlockMath math="(\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{\mathbf{S} \cup \{ \oslash \}} )" />
>
> The networking protocol is fundamentally identical for these blockchains. "Mining" algorithms are but an emergent property of the network, given the incentives for block creation.
>
> In Tezos, we make a blockchain protocol introspective by letting blocks act on the protocol itself. We can then express the set of protocols recursively as:
>
> <BlockMath math="\mathcal{P} = \lbrace (\mathbf{S}, \leq, \oslash, \mathbf{B} \subset \mathbf{S}^{(\mathbf{S} \times \mathcal{P}) \cup \{ \oslash \}} ) \rbrace" />

## The Blockchain

Tezo's blockchain (like all blockchains I know of) represents a sequence of operations. Each operation represents a sequence of _external operations_ and is signed by the address of the account performing the operation (called the _source address_). There are three kinds of external operations:

1. **Transaction**.

   These represent transfers of tokens from one account to another. If the recipient account is a smart contract, the transaction can also have associated "parameters" to be interpreted by the smart contract, or the transaction can specify a specific smart contract "entrypoint".

1. **Contract creation**.

   This operation creates a smart contract. This requires the source code of the smart contract, some tokens (transferred from the source address), and an initial state for the contract.

   (Every contract has some storage that specifies its state. The contents of the storage evolve over time as the contract runs and help determine its behavior, so when creating a contract you have to specify the initial storage contents.)

1. **Delegations**.

   These assign the tokens of the source account to serve as the stake of another account. This does not transfer any tokens, and only works for "implicit accounts", not smart contracts.

### Types of accounts

Accounts in Tezos store tokens, and have a public and private key. Knowledge of the private key is sufficient to spend the tokens stored in the account.

There are two types of accounts in Tezos:

1. **Implicit accounts**.

   These are just wallets. Tokens stored in an implicit account can be spent by anyone with access to the private key. Its address is the hash of its public key, which will start with `tz1`, `tz2` or `tz3`.

1. **Programmable accounts**.

   The behavior of programmable accounts is specified by a _smart contract_ (defined as some Michelson code). Its address will start with `KT1`. A payment to this account will not necessarily succeed.

   Each smart contract has some amount of storage used to keep track of its state. The contents of the storage can be read and modified from the Michelson code.

## [Michelson](https://tezos.gitlab.io/alpha/michelson.html) - The Smart Contracts Language

Smart contracts are specified in a simple programming language called Michelson. The language is low-level, so usually you actually write the contracts in [Ligo](https://ligolang.org/), then compile to Michelson.

> A Michelson program is a series of instructions that are run in sequence: each instruction receives as input the stack resulting of the previous instruction, and rewrites it for the next one. The stack contains both immediate values and heap allocated structures. All values are immutable and garbage collected.

> The Michelson program receives as input a stack containing a single pair whose first element is an input value and second element the content of the storage space. It must return a stack containing a single pair whose first element is the list of internal operations that it wants to emit, and second element is the new contents of the storage space. Alternatively, a Michelson program can fail, explicitly using a specific opcode, or because something went wrong that could not be caught by the type system (e.g. gas exhaustion).

Here is an example of a simple Michelson program:

```
parameter unit;
storage unit;
code
  {
    CAR;

    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH int 2; PUSH nat 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
    PUSH nat 2; PUSH nat 2; ADD; PUSH nat 4; ASSERT_CMPEQ;

    # Offset a timestamp by 60 seconds
    PUSH int 60; PUSH timestamp "2019-09-09T12:08:37Z"; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH timestamp "2019-09-09T12:08:37Z"; PUSH int 60; ADD;
    PUSH timestamp "2019-09-09T12:09:37Z"; ASSERT_CMPEQ;

    PUSH mutez 1000; PUSH mutez 1000; ADD;
    PUSH mutez 2000; ASSERT_CMPEQ;

    NIL operation;
    PAIR;
  }

```

If you're familiar with stack-based languages, it should be pretty clear what's going on here. Let's look at just this one line:

```
PUSH int 2; PUSH int 2; ADD; PUSH int 4; ASSERT_CMPEQ;
```

| Instruction     | Behavior                                                                                               | Current Stack State |
| --------------- | ------------------------------------------------------------------------------------------------------ | ------------------- |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2`                 |
| `PUSH int 2;`   | Pushes the int `2` onto the stack.                                                                     | `2,2`               |
| `ADD;`          | Pops the top two values off the stack, adds them together, then pushes the result back onto the stack. | `4`                 |
| `PUSH int 4;`   | Pushes the int `4` onto the stack.                                                                     | `4,4`               |
| `ASSERT_CMPEQ;` | Pops the top two items off the stack and crashes the contract if they are not the same.                | ` `                 |

Michelson's semantics are specified [here](https://tezos.gitlab.io/alpha/michelson.html#language-semantics) ([opcode reference](https://tezos.gitlab.io/alpha/michelson.html#operations-on-integers-and-natural-numbers)). Strangely a definition for `ASSERT_CMPEQ` isn't present on that page.

# The Tezos dev environment

(Most tezos development is done in OCaml.)

Tezos is mostly developed on Debian, and if that works for you, you can use the [official docs](https://tezos.gitlab.io/introduction/howtoget.html#setting-up-the-development-environment-from-scratch) which should always be up-to-date.

I like Windows, so I followed [Daniel Hines](https://roamresearch.com/#/app/TezosDev/page/C2UthnLRL)'s guide to get an environment working using WSL. There's lots of good information in there.

## Directory Structure

At the time of this writing, the directory structure of the master branch looks something like this:

```
.
├── devtools
├── docs
├── scripts
├── src
│   ├── [...]
│   ├── proto_XXX_letters
│   ├── proto_alpha
│   └── tooling
│       └── test
├── tests_python
├── tezt
└── vendors
```

I'm here to work on the protocol, so the most relevant folder under `src` is `proto_alpha`. The rest are just old versions of the protocol that you don't have to worry about.

</Layout>
