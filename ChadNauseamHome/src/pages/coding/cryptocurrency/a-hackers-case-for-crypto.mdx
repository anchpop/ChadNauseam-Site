<Layout
  subtitle="A Hacker's Case For Crypto"
  description="My perspective on blockchains, cryptocurrencies, etc."
>

Disclosure: I'm a protocol developer for a major cryptocurrency (not any of the ones mentioned in this post though). But I'm a protocol developer because I like cryptocurrencies, not the other way around.

So there's been a lot of people talking about cryptocurrency. but I noticed that the pro-cryptocurrency people focus on things I think are irrelevant, and the anti-cryptocurrency people are often unaware of what I consider to be the most exciting parts of cryptocurrencies.

So what are the exciting parts? I'll try to explain my perspective. The core is that I love the idea of just making a utility and distributing the source, so anyone who wants to can download and run it and (if they like) have complete control over what it does. If I die or get bored, I want the tool to live on in the SSDs of people who love it.

That's why I like the build system [Nix](https://nixos.org/), which lets you precisely describe how to build your code so anyone who builds it for a given architecture is guaranteed to get the exact same binary. It's why I like git, which makes it easy for people to share and merge their changes with one another. But most of all, it's why I like bittorrent, which lets people share files with one another without the need for any intermediary or corporation beyond an ISP. If any of this is appealing to you, I think you might be able to be convinced to like cryptocurrencies for the same reasons I do.

Let's think about the problem bittorrent solves. Bittorrent is a protocol that allows some people to "seed" a file. Anyone with the file's hash can use the bittorrent protocol to find that file's seeders and download it from them. So we can say it takes the problem of file distribution, which is quite easily solved with a central file server that you link people to, and makes it _decentralized_, so it doesn't depend on the continued good-faith of any particular person. Someone can pretend to seed a file and maliciously send you some other file, but the hash of their file wouldn't match the hash of the file you asked for, so your computer would automatically throw it away. This means that it only needs _one_ person to seed the file honestly, and all the evil in the world can't stop them from sending it to you. <Note>Well, they could DOS you or your ISP could cut off your internet connection or the government would arrest you, but this is still a much better security model than "let's just hope our guy keeps this link stays up forever".</Note>

This is actually a pretty complicated problem. How do you go from a hash to an IP address of people who are seeding a file without relying on a centralized server? Well this uses a pretty sophisticated bit of engineering called a [Distributed Hash Table](https://en.wikipedia.org/wiki/Distributed_hash_table), and it does technically involve connecting to at least one central sever to get the root of the table, but if that server starts misbehaving you can just switch to a different one without losing anything.

So the effect is I can make a utility, throw it up on bittorrent, and that's all I have to do. As long as anyone likes it, they can seed it, and it'll be available for everyone no matter what I do. Even if powerful organizations like Disney don't like my utility, they can't stop me from releasing my tool or you from downloading it. Even the government can't stop me as long as they're not willing to block [Mullvad](https://mullvad.net/en/). That's cool!

So the obvious question is: we've pretty much solved this problem in the context of serving files, but can we solve it in other domains? Even without cryptocurrency, the answer is yes. Any problem which can be expressed as a [CRDT](https://crdt.tech/), you can bittorrent-ize it. You can pretty simply modify bittorrent so that instead of identifying files with a hash, it identifies files signed with a private key. That means I can update my file and sign it with my private key and re-release it, and the same link will now point to both files instead of just the original. (Give every file a version number and add some tooling that automatically downloads whichever file has the latest version, and you're cooking with gas.) But it also means I can, for example, maintain a file with all of my tweets and share the link with my friends, and they can download my file and see my tweets, even ones I added after I shared the link with them. That's how you make a social network that no one controls, and you can do it without a spec of cryptocurrency. This is the idea behind Paul Frazee's [unwalled.garden](https://github.com/beakerbrowser/unwalled.garden), and it doesn't require a spec of cryptocurrency.

If you write the code for this, like Paul Frazee has, you've made a social network that truly belongs to the hackers. You can't change a thing about it without their consent – they'll just not download your change. It's like my dream of making a utility that lives on after I die, except it's a social utility instead of something that lives on your computer and doesn't talk to anyone else.

Not bad, but there are things you might want to do that can't be expressed with a CRDT. You can make Twitter or Google Docs like this, but you can't make Reddit or Hacker News. Twitter is "easy" because you already know who you follow, so you can just download their tweets. But anyone can submit a post to Hacker News and ideally everyone would be able to see it.

To solve _this_ problem, you need a distributed ledger. A ledger is basically a list of operations, like `["Chad posted link <X>", "Stacy upvoted post <Y>", ...]`. The ledger should be in the same order for everyone, and anyone should be able to add whatever they want to it<Note>up to bandwidth limits etc.)</Note>. Additonally, once something is in the ledger, its position in the ledger should never change.

Like how anyone can seed a torrent, anyone should be able to participate in distributing this ledger to people. It shouldn't be up to one person who might get hit by a bus or turn evil or be arrested at any time. It should be a community effort to keep the ledger up and keep sharing it with people who want it. And it should be very difficult for any organization, even a powerful one, to stop us.

Unfortunately, you can't put a ledger like this into a CRDT, so that dream is almost impossible.

## Almost impossible, but it can be done

Everyone should agree on the ledger, which means this is a problem of "distributed consensus". We don't want one bad actor to be able to ruin it for everyone, which means we want our consensus protocol to be byzantine fault tolerant (BFT). Byzantine fault tolerance means that the consensus algorithm works correctly even if some nodes misbehave, no matter what they do. For bittorrent, you only need one honest seeder to get your file, so it's definitely byzantine fault tolerant, but there's no way to make our distributed ledger _that_ tolerant. Instead, the best we can do is take a threshold like 50% or 33% and say that as long as there are fewer correctly-behaving nodes than that threshold, our consensus algorithm will behave correctly.

This is a much worse situation. It means we need some barrier to making nodes, because otherwise an attacker would just spin up an arbitrary number of nodes until they hit our threshold. For "proof of work" currencies like Bitcoin and present-day Ethereum, that barrier is acquiring computing power. For "proof of stake" currencies like Algorand and someday-but-hopefully-soon Ethereum, that barrier is liquidity of some asset. (For those curious, proof of work gives you a 50% threshold, and proof of stake usually gives you 25% or 33%)

## Why do these have to be currencies though?

Couldn't they just be distributed systems that hackers spin up as needed? Well, nothing stops you from doing that, but the fear is that not enough people will volunteer their computing power or their liquidity for it to be difficult for a powerful attacker to reach that threshold.

The resolution is to make everyone contribute something. If you want to use the network, you have to put money in. If you add security to the network by running an honest node, you take money out. In practice, you do this by creating a token and tracking who owns the token on the network. When someone runs an honest node the network mints tokens from nothing and gives it to them. They then sell that token to people who want to use the network, because to use the network you need to have a token and destroy it. This token is what makes it a "currency", although it's not really a currency anyone would want to use – it's just a roundabout way to get people who use the network to pay the people who make it work.

But that's just a practical consideration. Nothing stops you from taking any cryptocurrency design and removing the incentivization schemes. Your version will still benefit from all the other research that's being done.

## Problems

You might have noticed that it can cost tens of dollars to do a single transaction on Bitcoin or Ethereum, and that's a huge problem. The issue is that all distributed ledgers are limited in how many operations you can add per second, and there's a mini-bidding war to see how many tokens you're willing to lose to get your transaction in. If you want distributed ledgers to be usable for something like a social network, it's no good if it costs $60 to make a post! So the main problem that remains to be solved before we have practical distributed ledgers is scaling them up so the number of operations the ledger can support is much much higher. Remember, we want this to be a community effort where anyone can contribute to the network on their home computer, so we can't just buy a beefy server farm like Google can, we need something like bittorrent that works fine on a normal computer with a normal internet connection, but can scale to tens of thousands operations per second. Bitcoin currently supports about 5 operations per second, and Ethereum supports about 10, so we have a long way to go.

It's been 13 years (or something like that) since the original bitcoin whitepaper and this still isn't solved, but scaling is really hard! I swear that we're working on it! Let's briefly go over some of the problems and their solutions.

### There's a lot of redundant computation

Let's say the ledger has operations like `["Alice paid Bob $1", "Carol paid Danny $5", ...]`. You might want to compute everyone's balance, but if the ledger is very large, that might take a while. In general, the ledger is a list of operations that modify a state, but what you're really interested in is the current state. Currently, every cryptocurrency has everyone recompute the entire state themselves, but that leads to a lot of redundant work!

The obvious solution is to have one person compute it and ask them, but then you'd have to trust that they weren't lying. The trick here is to use a technology called ZK-snarks/starks/etc. that let you run an arbitrary computation and compute its result along with a _cryptographic proof_ that that result really is the result of running the computation. The beautiful thing is that this proof is small, a few bytes for snarks to a few kilobytes to starks, and can be checked in a snap. So you can let anyone calculate and share `(balance, proof)` and as long as one person is willing to do that, no one else needs to redo their work.

The problem was, although the proof can be checked almost instantly, the overhead of generating the proof used to be enormous. If it takes 100,000x longer to generate the proof than it does to run the computation, you're not really saving that much work compared to having everyone do the computation themselves! However, this is such an important problem that the cryptocurrency industry has poured billions of dollars into optimizing the proof-generation process, and we now have awesome tools like [Plonky2](https://blog.polygon.technology/introducing-plonky2/) and [Kimchi](https://minaprotocol.com/blog/kimchi-the-latest-update-to-minas-proof-system) that make the overhead more like 100x than 100,000x.

There are ZK-based layers on top of Ethereum _today_ that increase the operations per second dramatically, so this isn't some hypothetical solution. Making a fully-general solution is really hard, but despite that [zkSync](https://zksync.io/) has a very fast public test network that you can try out today.

### Everyone redundantly stores the full ledger

It's not theoretically necessary for every node to store the full ledger, and if you want to support a lot of operations per second you quickly run into bandwidth problems of just sending the ledger around. As a matter of fact, bandwidth is the current bottleneck for bitcoin and ethereum. That's why the current biggest research area is _data sharding_, which allows you to split up the ledger between multiple nodes.

It's harder than it sounds because, just like how you can check that a file you get from Bittorrent is the right one, you want to be able to check that someone is really storing the part of the ledger they're claiming to. The obvious way to check that is to just download the ledger, but that defeats the whole point of reducing bandwidth requirements! The trick is to use [data availability sampling](https://notes.ethereum.org/@vbuterin/r1v8VCULP), which allows you to check that someone is storing a whole piece of data while only downloading a tiny fraction of it.

This is being implemented on Ethereum with a project called [danksharding](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq).

### The ledger just keeps getting bigger

Usually you care more about what's happening now than what happened 10 years ago. For example, instead of storing everyone who ever up- or downvoted a 10 year old post, it's much more efficient to compute a total upvote and downvote count and discard the individual votes. Despite how inefficient it is to keep the full history, that's how current blockchains are designed, because it keeps things much simpler. Simplifying a little, we have now have really good schemes for:

1. "State rent", where you have to continuously pay to keep something stored in the network.

1. "State expiry", where old stuff is deleted after a time.

In both cases, a hash of the deleted data is kept, and if it's important anyone who has the data saved can restore it later.

### Finality is too slow and is only probabilistic

On modern chains, operations get added to the ledger pretty quick (usually a few seconds for Ethereum, but 5 minutes for Bitcoin), but there a small period where they might disappear or get reordered. That period is called _finality_ – as long as there's not too many dishonest nodes, once an operation has been in the ledger for longer than the finality period it's either very unlikely or impossible for it to be reordered or removed. The issue is that this finality period is too long! If something important rests on a transaction having gone though, it's really annoying to have to wait for finality. On Ethereum, the finality period is about a minute and on Bitcoin it's about an hour, and in both cases this is only _probabilistic_ finality which means there's still some small chance that it'll disappear in the future even if all nodes are honest.

Luckily, if you use proof of stake, we have lots of consensus algorithms for _deterministic_ finality these days. Once Ethereum switches to proof of stake (any day now...), they'll have pretty-good finality after just one block (and there will be a new block every 12 seconds), and guaranteed<Note> Guaranteed so long as less than 33% of the nodes are dishonest, that is.</Note> finality after two blocks.

</Layout>
