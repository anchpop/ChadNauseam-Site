<Layout
 subtitle="We have decentralized version control, but centralized version management"
 description="How can git be improved?"
>

## What Git doesn't do

Git handles "version control". You can store many versions of a folder, switch between them, share them with others, see their history, etc. 

One thing it doesn't do is what I'll call "version management". That is, let's say that me, you, Alice, and Bob are all working on a project together. 

If Alice makes a change to the project, she has to disseminate that change to the rest of us. She can do that by sending us a text-based patch (i.e. over email). When she does, we all add it to our local `main` branch.

What's interesting is that now we have some kind of ontological concept of "the project". When Alice sends everyone her patch, she's adding that patch to the social reality of "the project" is. 

This reality is fragile. Alice could send different people different patches, or only send patches to a subset. That would cause others to mean diverging things when referring to "the project".

The easiest way to make sure that never happens is to upload the project to GitHub. We can just say that the main branch on GitHub's server is "the project". When you make a change, you do that by pushing to the main branch. Once you do that, everyone else is now out-of-date until they pull. 

Bob could complain. "Hey, I made a commit on my main branch locally, and Alice else made a commit and pushed it to Github. Why can't we say that Github's server is out of date with *me*? What makes Github's server any better than my local machine? "

Well, it's [certainly not that GitHub has better uptime](https://news.ycombinator.com/item?id=32735734) (zing). But, when someone on the team wants to start developing a new feature, they have to pick a version to develop against. The version that people pick to develop against is going to be the one on GitHub's main branch, not Bob's. Whatever version they pick is what I'm calling "the project". 

## Decentralized version management

What would you do if you wanted to have a Git project with many contributors, but with *no* privileged person or centralized server? 

We'll assume for now that: 

1. You have a fixed set of contributors to the project
2. Who are known in advance 
3. Who are all honest and never make mistakes and never have network outages. 
4. Who all have synchronized clocks

Additionally, their messages to each other are always delivered and read within a certain bounded time (let's say 1 hour). And, bear with me here, they all have synchronized clocks.

Here's what I'm thinking. Label your contributors `[0..n)`, maybe by alphabetizing their names. Every hour, take `num_hours_passed_since_project_start % n` to get a number from `[0..n)`. That number is the contributor who's the "project leader" for the next hour.

At the beginning of each hour, if you're leader, you take all the changes you've been wanting to make to the main branch of "the project" and email them out. 

If you're not leader, you work on some other branch and wait for emails to come in. When an email comes, you check if the email is from the current project leader. If it does, you apply the patch to your local `main` branch.

Git may be decentralized version control, but this would be decentralized version *management*. Any one person dying doesn't stop "the project" from being updated, and nobody has any privileged role in the protocol. 

Of course, this is a terrible idea. But it's an idea. 

</Layout>

